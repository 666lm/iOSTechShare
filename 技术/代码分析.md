在研究under the hood的东西的时候，常常需要看编译器有没有做什么额外的处理，其相关实现和调用过程。也常需要借助工具来帮助我们研究。这里是对研究iOS under the hood相关知识点、开源代码和工具的简单描述。

1. 编译的几个阶段；
2. ARM汇编；
3. 开源代码；
4. Clang工具的命令。	

# 编译的几个阶段

可以阅读objc.io的[编译器](http://objccn.io/issue-6-2/)、[Mach-O可执行文件](http://objccn.io/issue-6-3/)。当然也可以查看[Clang](http://clang.llvm.org/)的文档、或者《编译原理》。

查看编译hello.m源文件需要几个不同的阶段

	$ clang -ccc-print-phases hello.m
	
## 预处理

	$ clang -E hello.c | less

用 Xcode 查看任意文件的预处理输出结果：Product -> Perform Action -> Process.	
* 符号化 (Tokenization)
* 宏定义的展开
* \#include 的展开

## 语法和语义分析

/*
	$ clang -Xclang -dump-tokens hello.m
	$ clang -Xclang -ast-dump -fsyntax-only hello.m 
*/
	
	$ clang -S -o - helloworld.c

用 Xcode 查看任意文件的汇编输出结果：Product -> Perform Action -> Assemble.	
* 将符号化后的内容转化为一棵解析树 (parse tree)
* 解析树做语义分析
* 输出一棵抽象语法树（Abstract Syntax Tree* (AST)）	 
## 生成代码和优化

* 将 AST 转换为更低级的中间码 (LLVM IR)
* 对生成的中间码做优化
* 生成特定目标代码
* 输出汇编代码

## 汇编器

* 将汇编代码转换为目标对象文件。

## 链接器

* 将多个目标对象文件合并为一个可执行文件 (或者一个动态库)

# ARM汇编

对于iOS的汇编，船哥的这个[iOS汇编教程](http://beyondvincent.com/blog/2013/06/19/90/)翻译应该就够了。

[iOS 逆向之ARM汇编](http://www.cnblogs.com/csutanyu/p/3575297.html)

[iOS ABI Function Call Guide](https://developer.apple.com/library/ios/documentation/Xcode/Conceptual/iPhoneOSABIReference/iPhoneOSABIReference.pdf)

工具IDA, [Hopper](http://www.hopperapp.com/)

[Object File Inspection Tools](https://www.mikeash.com/pyblog/friday-qa-2011-12-02-object-file-inspection-tools.html)

[Disassembling the Assembly, Part 1](https://www.mikeash.com/pyblog/friday-qa-2011-12-16-disassembling-the-assembly-part-1.html)

[Disassembling the Assembly, Part 2](https://www.mikeash.com/pyblog/friday-qa-2011-12-23-disassembling-the-assembly-part-2.html)

[Disassembling the Assembly, Part 3: ARM edition](https://www.mikeash.com/pyblog/friday-qa-2011-12-30-disassembling-the-assembly-part-3-arm-edition.html)

[The Hopper Disassembler](https://www.mikeash.com/pyblog/friday-qa-2012-01-06-the-hopper-disassembler.html)

[ARM64 and You](https://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html)

# 开源代码

包括:

1. Cocoa的互换框架[GNUStep](http://gnustep.org/)
2. [Apple Open Source](http://opensource.apple.com/)，[tarballs](http://opensource.apple.com/tarballs/)目录下载源码，[source](http://opensource.apple.com/source/)目录查看源码。
3. [Clang](clang.llvm.org)， [LLVM](http://llvm.org/)

# Clang 命令

  -c                      Only run preprocess, compile, and assemble steps
  
  -E                      Only run the preprocessor
  
  -S                      Only run preprocess and compilation steps
  
  -emit-ast               Emit Clang AST files for source inputs
  
  -emit-llvm              Use the LLVM representation for assembler and object files
  
  -g                      Generate source level debug information
  
  -o <file>               Write output to <file>
  
  -ObjC                   Treat source input files as Objective-C inputs
  
  -rewrite-legacy-objc    Rewrite Legacy Objective-C source to C++
  
  -rewrite-objc           Rewrite Objective-C source to C++

# 总结

在预处理阶段，Product -> Perform Action -> Process 是最方便的。

查看生成的代码，可能不同的点，工具有所不同。

## ARC

[Is it possible to see the code generated by ARC at compile time?](http://stackoverflow.com/questions/10429857/is-it-possible-to-see-the-code-generated-by-arc-at-compile-time)

ARC：汇编查看，Hopper是可阅读性比较高的。或者LLDB。

# 更多

[http://ios.jobbole.com/82124/](iOS开发中可以节省50%编译等待时间的几个措施)
